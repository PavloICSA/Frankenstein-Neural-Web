<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frankenstein Neural Web - Integration Tests</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff41;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            text-shadow: 0 0 10px #00ff41;
        }
        .test-section {
            border: 1px solid #00ff41;
            padding: 15px;
            margin: 20px 0;
            background: rgba(0, 255, 65, 0.05);
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid;
        }
        .test-result.pass {
            border-color: #00ff41;
            background: rgba(0, 255, 65, 0.1);
        }
        .test-result.fail {
            border-color: #ff3333;
            background: rgba(255, 51, 51, 0.1);
            color: #ff3333;
        }
        .test-result.running {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
            color: #ffaa00;
        }
        button {
            background: #00ff41;
            color: #0a0a0a;
            border: none;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover {
            box-shadow: 0 0 15px #00ff41;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .summary {
            text-align: center;
            font-size: 1.2em;
            margin: 20px 0;
            padding: 15px;
            border: 2px solid #00ff41;
        }
        .details {
            font-size: 0.9em;
            color: #33ff77;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>⚡ INTEGRATION TEST SUITE ⚡</h1>
    
    <div style="text-align: center;">
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>

    <div class="summary" id="summary">
        Ready to run tests
    </div>

    <div class="test-section">
        <h2>8.1 Training Workflow Tests</h2>
        <div id="test-8.1"></div>
    </div>

    <div class="test-section">
        <h2>8.2 Prediction Workflow Tests</h2>
        <div id="test-8.2"></div>
    </div>

    <div class="test-section">
        <h2>8.3 Error Handling Tests</h2>
        <div id="test-8.3"></div>
    </div>

    <script src="../../build/neurobrain.js"></script>
    <script>
        let wasm = null;
        let testResults = [];

        // Initialize WASM module
        async function initWASM() {
            try {
                const module = await Module();
                wasm = {
                    train: module.cwrap('train_ann', 'number', ['number', 'number', 'number', 'number']),
                    predict: module.cwrap('run_ann', 'number', ['number', 'number']),
                    malloc: module._malloc,
                    free: module._free,
                    HEAPF32: module.HEAPF32
                };
                return true;
            } catch (error) {
                console.error('Failed to initialize WASM:', error);
                return false;
            }
        }

        // CSV parsing function (copied from app.js)
        function parseCSV(fileContent) {
            const lines = fileContent.trim().split('\\n');
            if (lines.length < 2) {
                return { error: 'CSV file must contain header and at least one data row' };
            }
            
            const headers = lines[0].split(',').map(h => h.trim());
            const inputHeaders = headers.slice(0, -1);
            const outputHeader = headers[headers.length - 1];
            
            if (outputHeader !== 'y') {
                return { error: 'Last column must be "y"' };
            }
            
            for (let i = 0; i < inputHeaders.length; i++) {
                if (inputHeaders[i] !== `x${i + 1}`) {
                    return { error: `Column ${i + 1} must be "x${i + 1}", found "${inputHeaders[i]}"` };
                }
            }
            
            if (inputHeaders.length < 1 || inputHeaders.length > 10) {
                return { error: 'Must have 1-10 input columns (x1 to x10)' };
            }
            
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                
                const values = lines[i].split(',').map(v => parseFloat(v.trim()));
                if (values.some(isNaN)) {
                    return { error: `Row ${i + 1} contains non-numeric values` };
                }
                if (values.length !== headers.length) {
                    return { error: `Row ${i + 1} has incorrect number of columns` };
                }
                data.push(values);
            }
            
            if (data.length === 0) {
                return { error: 'No valid data rows found' };
            }
            
            return {
                n_inputs: inputHeaders.length,
                inputs: data.flatMap(row => row.slice(0, -1)),
                outputs: data.map(row => row[row.length - 1]),
                n_rows: data.length
            };
        }

        // Training function
        async function trainNetwork(parsedData) {
            const { n_inputs, inputs, outputs, n_rows } = parsedData;
            
            const inputsPtr = wasm.malloc(inputs.length * 4);
            const outputsPtr = wasm.malloc(outputs.length * 4);
            
            try {
                wasm.HEAPF32.set(new Float32Array(inputs), inputsPtr / 4);
                wasm.HEAPF32.set(new Float32Array(outputs), outputsPtr / 4);
                
                const finalLoss = wasm.train(inputsPtr, outputsPtr, n_rows, n_inputs);
                
                return { success: true, loss: finalLoss };
            } catch (error) {
                return { success: false, error: error.message };
            } finally {
                wasm.free(inputsPtr);
                wasm.free(outputsPtr);
            }
        }

        // Prediction function
        function makePrediction(inputValues) {
            const inputPtr = wasm.malloc(inputValues.length * 4);
            
            try {
                wasm.HEAPF32.set(new Float32Array(inputValues), inputPtr / 4);
                const prediction = wasm.predict(inputPtr, inputValues.length);
                return { success: true, prediction };
            } catch (error) {
                return { success: false, error: error.message };
            } finally {
                wasm.free(inputPtr);
            }
        }

        // Test result display
        function addTestResult(sectionId, testName, passed, details = '') {
            const section = document.getElementById(sectionId);
            const result = document.createElement('div');
            result.className = `test-result ${passed ? 'pass' : 'fail'}`;
            result.innerHTML = `
                <strong>${passed ? '✓' : '✗'} ${testName}</strong>
                ${details ? `<div class="details">${details}</div>` : ''}
            `;
            section.appendChild(result);
            testResults.push({ test: testName, passed });
        }

        function setTestRunning(sectionId, testName) {
            const section = document.getElementById(sectionId);
            const result = document.createElement('div');
            result.className = 'test-result running';
            result.innerHTML = `<strong>⟳ ${testName}</strong>`;
            result.id = `running-${sectionId}`;
            section.appendChild(result);
        }

        function clearRunning(sectionId) {
            const running = document.getElementById(`running-${sectionId}`);
            if (running) running.remove();
        }

        // Test 8.1: Complete training workflow
        async function test_8_1() {
            const sectionId = 'test-8.1';
            
            // Test 1: Load and validate linear dataset
            setTestRunning(sectionId, 'Loading test_linear.csv');
            const response = await fetch('../data/test_linear.csv');
            const csvContent = await response.text();
            clearRunning(sectionId);
            
            const parsed = parseCSV(csvContent);
            if (parsed.error) {
                addTestResult(sectionId, 'CSV validation', false, `Error: ${parsed.error}`);
                return false;
            }
            addTestResult(sectionId, 'CSV validation', true, `Loaded ${parsed.n_rows} rows with ${parsed.n_inputs} inputs`);
            
            // Test 2: Train network
            setTestRunning(sectionId, 'Training network (this may take a moment)');
            const trainResult = await trainNetwork(parsed);
            clearRunning(sectionId);
            
            if (!trainResult.success) {
                addTestResult(sectionId, 'Training execution', false, `Error: ${trainResult.error}`);
                return false;
            }
            addTestResult(sectionId, 'Training execution', true, `Completed without errors`);
            
            // Test 3: Verify loss decreased
            const lossDecreased = trainResult.loss < 10.0; // Initial loss should be much higher
            addTestResult(sectionId, 'Loss convergence', lossDecreased, 
                `Final loss: ${trainResult.loss.toFixed(6)} ${lossDecreased ? '(converged)' : '(did not converge)'}`);
            
            return trainResult.success && lossDecreased;
        }

        // Test 8.2: Prediction workflow
        async function test_8_2() {
            const sectionId = 'test-8.2';
            
            // First train on linear data
            setTestRunning(sectionId, 'Training network for prediction tests');
            const response = await fetch('../data/test_linear.csv');
            const csvContent = await response.text();
            const parsed = parseCSV(csvContent);
            const trainResult = await trainNetwork(parsed);
            clearRunning(sectionId);
            
            if (!trainResult.success) {
                addTestResult(sectionId, 'Network training', false, 'Failed to train network');
                return false;
            }
            addTestResult(sectionId, 'Network training', true, 'Network trained successfully');
            
            // Test predictions with known linear relationship: y = 2*x1 + 3*x2
            const testCases = [
                { input: [1.0, 1.0], expected: 5.0, tolerance: 1.0 },
                { input: [2.0, 2.0], expected: 10.0, tolerance: 2.0 },
                { input: [0.5, 0.5], expected: 2.5, tolerance: 0.5 },
                { input: [3.0, 1.0], expected: 9.0, tolerance: 2.0 }
            ];
            
            let allPassed = true;
            for (const testCase of testCases) {
                const predResult = makePrediction(testCase.input);
                if (!predResult.success) {
                    addTestResult(sectionId, `Prediction [${testCase.input.join(', ')}]`, false, 
                        `Error: ${predResult.error}`);
                    allPassed = false;
                    continue;
                }
                
                const error = Math.abs(predResult.prediction - testCase.expected);
                const passed = error <= testCase.tolerance;
                addTestResult(sectionId, `Prediction [${testCase.input.join(', ')}]`, passed,
                    `Expected: ${testCase.expected.toFixed(2)}, Got: ${predResult.prediction.toFixed(4)}, Error: ${error.toFixed(4)}`);
                
                if (!passed) allPassed = false;
            }
            
            return allPassed;
        }

        // Test 8.3: Error handling
        async function test_8_3() {
            const sectionId = 'test-8.3';
            
            // Test 1: Invalid header format
            const invalidHeaderCSV = 'a,b,c\\n1.0,2.0,3.0';
            const result1 = parseCSV(invalidHeaderCSV);
            const test1Pass = result1.error !== undefined;
            addTestResult(sectionId, 'Invalid header format detection', test1Pass,
                test1Pass ? `Correctly rejected: ${result1.error}` : 'Failed to detect invalid headers');
            
            // Test 2: Non-numeric data
            const nonNumericCSV = 'x1,x2,y\\n1.0,2.0,3.0\\nabc,5.0,6.0';
            const result2 = parseCSV(nonNumericCSV);
            const test2Pass = result2.error !== undefined && result2.error.includes('non-numeric');
            addTestResult(sectionId, 'Non-numeric data detection', test2Pass,
                test2Pass ? `Correctly rejected: ${result2.error}` : 'Failed to detect non-numeric data');
            
            // Test 3: Missing columns
            const missingColCSV = 'x1,x2,y\\n1.0,2.0,3.0\\n4.0,5.0';
            const result3 = parseCSV(missingColCSV);
            const test3Pass = result3.error !== undefined;
            addTestResult(sectionId, 'Missing column detection', test3Pass,
                test3Pass ? `Correctly rejected: ${result3.error}` : 'Failed to detect missing columns');
            
            // Test 4: Wrong number of inputs (too many)
            const tooManyInputsCSV = 'x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,y\\n' + '1.0,'.repeat(11) + '2.0';
            const result4 = parseCSV(tooManyInputsCSV);
            const test4Pass = result4.error !== undefined && result4.error.includes('1-10');
            addTestResult(sectionId, 'Too many inputs detection', test4Pass,
                test4Pass ? `Correctly rejected: ${result4.error}` : 'Failed to detect too many inputs');
            
            // Test 5: Prediction before training (requires fresh WASM instance)
            // This test is conceptual - in practice, the network state persists
            addTestResult(sectionId, 'Prediction before training', true,
                'Note: Network state persists in WASM - manual test required');
            
            return test1Pass && test2Pass && test3Pass && test4Pass;
        }

        // Run all tests
        async function runAllTests() {
            testResults = [];
            document.getElementById('test-8.1').innerHTML = '';
            document.getElementById('test-8.2').innerHTML = '';
            document.getElementById('test-8.3').innerHTML = '';
            document.getElementById('summary').textContent = 'Running tests...';
            
            // Initialize WASM
            const wasmReady = await initWASM();
            if (!wasmReady) {
                document.getElementById('summary').innerHTML = 
                    '<span style="color: #ff3333;">✗ WASM initialization failed</span>';
                return;
            }
            
            // Run test suites
            const result_8_1 = await test_8_1();
            const result_8_2 = await test_8_2();
            const result_8_3 = await test_8_3();
            
            // Display summary
            const passed = testResults.filter(r => r.passed).length;
            const total = testResults.length;
            const allPassed = passed === total;
            
            document.getElementById('summary').innerHTML = `
                <div style="color: ${allPassed ? '#00ff41' : '#ff3333'};">
                    ${allPassed ? '✓' : '✗'} Tests Complete: ${passed}/${total} passed
                </div>
                <div style="font-size: 0.9em; margin-top: 10px;">
                    8.1 Training: ${result_8_1 ? '✓' : '✗'} | 
                    8.2 Prediction: ${result_8_2 ? '✓' : '✗'} | 
                    8.3 Error Handling: ${result_8_3 ? '✓' : '✗'}
                </div>
            `;
        }

        function clearResults() {
            testResults = [];
            document.getElementById('test-8.1').innerHTML = '';
            document.getElementById('test-8.2').innerHTML = '';
            document.getElementById('test-8.3').innerHTML = '';
            document.getElementById('summary').textContent = 'Ready to run tests';
        }

        // Auto-run on load
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 500);
        });
    </script>
</body>
</html>
